{
    "collab_server" : "",
    "contents" : "# --  dwj : 15th April 2018\n# --  Cleaned version of initial processing script, annotated\n#\n# --  Depends on:\n#         load_all_tables.R\n#\n# --  Produces:\n#         TRS.sx.traj         -- data.frame of all participants symptoms trajectories (PANSS scores over time) - multiple rows per participant\n#         TRS.rx.traj         -- data.frame of all participants treatments - multiple rows per participant\n#         TRS.sofas.traj      -- data.frame of all participants social and occupational functioning scores - multiple rows per participant\n#         allIDs              -- vector of all participant IDs processed\n#         keyvars             -- preserves keyvars data (from CATIE source data) for use when collating data for analysis (see tabulate_cases.R)\n#         demog.tab           -- same, for demog.tab (CATIE source data)\n#         PANSS.tab           -- ditto for PANSS.tab (CATIE source data) \n#         pmhx.tab            -- past medical history (extracted from CATIE source data)\n#         SCID.tab            -- psychiatric data (SCID, extracted from CATIE source data)\n#         root.path           -- preserve root path\n#         data.path           -- and data path\n#\n# --  Directory structure required:\n#         Root\n#           |\n#           |- Code\n#                 |\n#                 |- load_all_tables.R\n#           |- Data\n#                 |\n#                 |- demographic_baseline_meds.csv\n#                 |- dgsposys01.csv\n#                 |- doses_of_drugs.csv\n#                 |- keyvars01.csv\n#                 |- macvlnce01.csv\n#                 |- neurobatt01.csv\n#                 |- PANSS.csv\n#                 |- qol01.csv\n#                 |- scid_ph01.csv\n\n# -- This script assumes the current working directory is Root/Code.\n\n# -- Outline of the TRRIP concensus (Howes et al, 2016) --------------------------------------\n#\n# -- 1: Current symptoms -- \n#     a) BPRS, PANSS etc. at least Moderate Severity\n#     b) Duration : >= 12 weeks\n#     d) subjective distress - NOT required\n#     c) Functioning - moderate impairment on validated scale SOFAS or CGI??\n#\n# -- At least moderate (>= 4) in two symptoms in each POS, NEG and GEN domains\n#    OR at least one severe >= 6.\n#\n# -- So, treatment resistance positive = 2 sx at 4+, or 1 symptom at 6+\n#    and a patient can be treatment resistant in more than one domain (POS, NEG and GEN)\n\n# -- At CATIE baseline, first episode patients were excluded, so included patients have symptoms present > 3 years and had not\n#    started antipsychotic treatment in the preceding 12 months (i.e. had been treated for longer)\n\n# -- Setup environment\n  rm(list = ls())\n  # -- Paths (assumes working directory is root)\n  root.path <- \"./\"\n  data.path <- \"../Data/\"\n  setwd( root.path )\n  source( paste( root.path, \"load_all_tables.R\", sep = \"\") )\n\n  require(dplyr)\n\n# -- 1 : Social and occupational functioning (SOFAS/PSP proxy score) \n#        Here, we define the four \"domains\" in the PSP version of SOFAS\n#        in terms of the variables available in CATIE's multiple instruments\n  \n  A.social_act.func.QoL.tab <- c(\"inst_rol\")   # lower scores worse \n  # -- we take SOFAS socially useful activity/study as the CATIE QoL instrumental role variable\n\n  B.pers.social.QoL.tab     <- c(\"intr_rel\")\n  # -- SOFAS personal and social activity as the CATIE QoL interpersonal relations variable\n\n  C.self_care.QoL.tab       <- c(\"qol24a\", ## Wash two or more times daily 0 = NO, 1 = YES, 2 = No opport.\n                                 \"qol24b\", ## Clean room (score as above)\n                                 \"qol24c\", ## Do own laundry (score as above)\n                                 \"qol24d\", ## help to do chores (score as above)\n                                 \"qol25j1\", ## remind for appts\n                                 \"qol25j2\", ## take to appts\n                                 \"qol25j3\", ## remind for meds\n                                 \"qol25j4\", ## give meds\n                                 \"qol26a\", ## independent living = 1\n                                 \"qol26b\", ## minimally supported accom = 1\n                                 \"qol26c\", ## moderately supported accom = 1\n                                 \"qol26d\", ## extremely restrictive accom = 1\n                                 \"qol26e\"  ## homeless = 1\n                               )\n  # -- self care (in SOFAS/PSP) is an aggregate of a number of variables in the CATIE instruments\n  \n  # -- for disturbed/aggressive behaviour in SOFAS/PSP we use the MacArthur items:  \n  D.disturb.aggress.viol.tab <- c(\"mac2a\", \"mac4a\", \"mac6a\", \"mac8a\", \"mac10a\",\"mac12a\",\"mac14a\",\"mac16a\",\"mac17a\",        \n                                 \"mac18a\" )\n  # -- MacArthur tool : sum of only macxx items recording *patient* directing aggression outwards (rather than \n  #    victim or target of aggression ), removing 97 and 98 entries.\n\n# -- Now code the domains for pseudo-SOFAS\n  id.cols <- c(\"src_subject_id\", \"phase_ct\", \"visday\", \"truncvis\")\n  temp.SOFAS <- QoL.tab[ , c(id.cols, A.social_act.func.QoL.tab, B.pers.social.QoL.tab, C.self_care.QoL.tab )  ] \n  temp.viol  <- viol.tab[ , c(id.cols, D.disturb.aggress.viol.tab ) ]\n\n# -- Join temp.SOFAS and temp.viol\nSOFAS <- left_join( temp.SOFAS, temp.viol )\n\n\n# -- Aggressive / Disturbed behaviour -- Domain D for SOFAS / PSP\n  # -- we use the sum of the MacArthur Abbreviated Community Aggression\n  #    where a 1 indicates an act of aggression in any of the categories.\n  #    the sum is a proxy for aggression across all categories - total score = 0 ... 10\n  t.sofas <- SOFAS[ , D.disturb.aggress.viol.tab ]\n  t.sofas[ t.sofas > 1 ] <- 0    \n  # -- we assume codes 97 and 98 (indicating refused or forgotten) are 0 so at worst, we are likely underestimating magnitude\n  sum.viol <- rowSums( t.sofas, na.rm = TRUE )\n  SOFAS$D.aggress <- sum.viol\n\n# -- Socially useful Activity and/or Study -- Domain A for SOFAS/PSP\n  # -- we use the Instrumental Role subset of Heinrich QOL (1984)\n  #    Scoring (from Heinrich et al 1984) : \n  #      * 6-5 == excellent / little impairment\n  #      * we use < 3 as moderate (e.g. 2.9 would be moderate, 4.9 - 4.3 would be mild)\n  #      * 1-0 == severe impairment\n  SOFAS$A.social <- SOFAS[ , c(\"inst_rol\")]\n\n# -- Personal and Social function -- Domain B for SOFAS/PSP\n  # -- We use the Interpersonal Relations subset of Heinrich QOL\n  #    Scores as above for Activity/Study Domain A\n  SOFAS$B.personal <- SOFAS[ , c(\"intr_rel\")]\n\n# -- Compute the self-care element : this is tougher because it's not cleanly captured by any of the Heinrich QOL scores in CATIE \n  # -- Needs to be assembled (rather arbitratily) as follows :\n  t.self <- SOFAS[ , C.self_care.QoL.tab ]\n  # -- split into three areas :\n  t.home <- t.self[,c(\"qol26a\", \"qol26b\", \"qol26c\", \"qol26d\", \"qol26e\")]  # home status (independent, minimal restric, moderate restric, extreme restrict, homeless)\n  t.care <- t.self[,c(\"qol24a\", \"qol24b\", \"qol24c\", \"qol24d\")]            # self care\n  t.indep<- t.self[,c(\"qol25j1\", \"qol25j2\", \"qol25j3\", \"qol25j4\")]        # independence - needing help with reminders / taking to appts and reminders/ taking meds\n\n# -- for the home/independence status (in past 30 days), take the worst (rightmost) column as the estimate.\n  C.home <- rep(0, NROW( t.home ))\n  for( i in 1:NROW( t.home ) ) {\n    C.home[i] <- 6 - max( t.home[i,] * c(1,2,3,4,5) )\n  }\n  # -- The resulting score C.home is as follows:\n  #     : 5 -- best (fully independent)\n  #     : 4 -- minimally supported accom\n  #     : 3 -- moderate supported accom\n  #     : 2 -- extremely restricted accom\n  #     : 1 -- homeless\n  #  NB : 6 ==> no data entered\n\n# -- for self care, 0 = No (poor), 1 = yes (good) and 2 = no opportunity (suggesting worse independent function)\n  C.selfcare <- rep(0, NROW( t.care ))\n  for( i in 1:NROW( t.care ) ) {\n    C.selfcare[i] <- length( which( t.care[i,] == 1) )\n  }\n  # -- The resulting score for C.selfcare is then as follows:\n  #     : 4 -- best (wash, laundry, clean room, do chores )\n  #     : 3 -- 3 of the above\n  #     : 2 -- manages only 2 of above\n  #     : 1 -- managed only 1 of above\n  #     : 0 -- very poor, manages NONE of above\n\n# -- For independence, count number of 1's in row of 4 x 0/1 \n#     1 => Yes, (worse function) needs help, \n#     0 => no does not need help (better function)\n  C.indep <- rep(0, NROW( t.indep ))\n  for( i in 1:NROW( t.indep ) ) {\n    C.indep[i] <- 4 - length( which( t.indep[i,] == 1) )\n  }\n  # -- The resulting score for C.indep is then: \n  #     : 4 -- best : fully independent\n  #     : 0 -- worst : requires help in all domains\n\n# -- Arrange scores in same rank order (best - worst)\nSOFAS$C.accom <- C.home            # 5 = best, 0 = worst, 6 = no data\nSOFAS$C.selfcare <- C.selfcare     # 4 = best, 0 = worst\nSOFAS$C.indep    <- C.indep        # 4 = best, 0 = worst\n\n\n# -- PANSS scores and tresholds -------------------------------------------------------------------------\n\n# -- define criteria as a function\n  aboveThresh <- function( V ) {\n    four <- length( which( V >= 4) )\n    six  <- length( which( V >= 6 ) )\n    if( four >= 2 | six >= 1 ) {\n      ## meets threshold\n      return( 1 )\n    } else {\n      ## does not meet threshold\n      return( 0 )\n    }\n  }\n\n  panss_TRS <- function( P ) {\n    # -- takes a table of PANSS scores (cols = P1, P2, ... N1, N2, ... G1, G2, .... G16 and rows = participants)\n    #    (which represent ALL PANSS ratings over the entire trial for every participant)\n    #    and computes a TRS *absolute* symptom inclusion profile using aboveThresh()\n    #    NOTE : absolute column references used - so the table MUST be in P, N and G format\n    #    with cols 1 ... 7 = Positive 1-7, 8 ... 14 = Negative and 15 ... 30 = general\n    \n    ## 1) positive symptoms\n    P.pos          <- data.matrix( P[ , 1:7] )\n    TRS.POS        <- as.numeric( apply( P.pos, MARGIN = 1, FUN = aboveThresh ) )\n    total.POS      <- as.numeric( apply( P.pos, MARGIN = 1, FUN = sum, na.rm = TRUE ) )\n    adj.total.POS  <- total.POS - 7\n    ## note adj.total.POS is baseline 7 adjusted to enable computation of change later\n    \n    P.neg          <- data.matrix( P[ , 8:14] )\n    TRS.NEG        <- as.numeric( apply( P.neg, MARGIN = 1, FUN = aboveThresh ) )\n    total.NEG      <- as.numeric( apply( P.neg, MARGIN = 1, FUN = sum, na.rm = TRUE ) )\n    adj.total.NEG  <- total.NEG - 7\n    \n    P.gen          <- data.matrix( P[ , 15:30] )\n    TRS.GEN        <- as.numeric( apply( P.gen, MARGIN = 1, FUN = aboveThresh ) ) \n    total.GEN      <- as.numeric( apply( P.gen, MARGIN = 1, FUN = sum, na.rm = TRUE ) ) \n    adj.total.GEN  <- total.GEN - 16\n      \n    ## return a data.frame\n    return( data.frame( TRS.pos = TRS.POS, total.POS = total.POS, adj.total.POS = adj.total.POS,\n                        TRS.neg = TRS.NEG, total.NEG = total.NEG, adj.total.NEG = adj.total.NEG, \n                        TRS.gen = TRS.GEN, total.GEN = total.GEN, adj.total.GEN = adj.total.GEN ))\n  }\n  \n  panss_5Factor <- function( P ) {\n    # -- takes a table of PANSS scores (cols = P1, P2, ... N1, N2, ... G1, G2, .... G16 and rows = participants)\n    #    and computes the Five Factor model for each participant.  Legacy code.\n    five.factor <- list( neg = c(\"neg_n3\",\"neg_n6\",\"neg_n2\",\"neg_n4\",\"neg_n1\",\"gps_g7\"), \n                         disorg = c(\"pos_p2\",\"gps_g11\",\"gps_g10\",\"gps_g13\",\"neg_n5\",\"neg_n7\",\"gps_g5\"),\n                         excite = c(\"gps_g8\",\"gps_g14\",\"pos_p7\",\"pos_p4\"),\n                         pos = c(\"pos_p1\",\"gps_g9\",\"pos_p3\",\"pos_p6\",\"pos_p5\"),\n                         depanx = c(\"gps_g2\",\"gps_g3\",\"gps_g6\",\"gps_g4\") \n    )\n    \n    # compute domain scores without adjustment\n    P.neg          <- rowSums( P[ , five.factor$neg ] )\n    P.disorg       <- rowSums( P[ , five.factor$disorg ] )\n    P.excite       <- rowSums( P[ , five.factor$excite ] )\n    P.pos          <- rowSums( P[ , five.factor$pos ] )\n    P.depanx       <- rowSums( P[ , five.factor$depanx ] )\n    \n    ## return a data.frame\n    return( data.frame( ID = P$src_subject_id, phase = P$phase_ct, visday = P$visday, truncvis = P$truncvis,\n                             F5.pos = P.pos, F5.neg = P.neg, F5.disorg = P.disorg, F5.excite = P.excite, F5.depanx = P.depanx))\n  }\n  \n  # -- convert phases to a factor\n  PANSS.tab$phase_ct <- factor(PANSS.tab$phase_ct, levels(PANSS.tab$phase_ct)[c(6,1:5)])\n  trialPhases <- levels( PANSS.tab$phase_ct )\n  \n  # -- Numerical code for phase labels:\n  numeric.trialPhases <- c(\"Pre-Rand\" = 1, \"Phase 1/1A\" = 2, \"Phase 1B\" = 2,  \"Phase 2\" = 3, \"Phase 3\" = 4, \"Phase 4\" = 4)\n  \n  # -- Assemble a data frame of PANSS absolute inclusion crtieria over every participant at each recorded assessment\n  TRS.sx <- panss_TRS( PANSS.tab[,5:NCOL(PANSS.tab)] )\n  TRS.sx <- cbind( PANSS.tab[ , 1:4], TRS.sx )\n  \n  PANSS.F5 <- panss_5Factor( PANSS.tab )\n\n# -- Functional impairment --------------------------------------------------------------------------------------------\n#     This represents a compromise given no SOFAS / PSP in CATIE\n#     The PSP operationalises the SOFAS by specifying four areas (A-D) and then placing patients\n#     on a SOFAS-like 0-100 scale based on meeting criteria in A through D (See Morosini et al 2000, Acta Psychiatrica Scandinavica)\n\n#     We have a table of SOFAS scores (derived above) in the following column order\n#         [A.social, B.personal, C.accom, C.selfcare, C.indep, D.aggress]\n\n# --  The TRIPP concensus requires 60 or less (moderate) impairment on SOFAS.\n#     We apply the (following) rubric to work out the proxy SOFAS score based on Morosini's\n#     operationalised version, the PSP.\n#\n#     - To score 60 or less on the PSP/SOFAS (=moderate overall impairment)\n#       the participant must have 'marked' impairment in one of A-C, with / without 'manifest' difficulty in D\n#\n#     - To score 50 or less, two of A-C or severe in one of A-C, with/without 'manifest' difficult in D\n#\n#     - To score 40 of less, 'severe' difficulties in one of A-C, with 'marked' difficulties in at least one of A-C\n#       OR 'marked' dificulties in D.\n\n  sofasAboveThresh <- function( V ) {\n    # -- Takes a row vector V of values and applies the following logic over the four domains in PSP/SOFAS \n    \n    # -- Section D - aggresion / disturbed behaviour\n    #       This is relatively easy to score, because 'marked' is\n    #       defined as including breaking/wrecking objects, insulting behaviour, and \n    #       'severe' is frequent verbal threats or frequent physical assaults.\n    #\n    # -- However, Morosini defines 'Occasional' (rather than frequent) as 3 or more incidents.\n    #     -- So, we can operationalise this as D.aggress >= 3.  \n    #        We use the MacArthur Community Violence scores in CATIE, which conveniently scores separate and increasing magnitude\n    #        of aggression --> violence with a minimum of \"throwing objects\" and a maximum of using a knife/firearms.\n    #     -- If more than 3 categories are \"yes\", this implies *at least* occasional aggression making\n    #        section D at least 'marked' if not severe.\n    thresh.D <- ifelse( V$D.aggress >= 3, 1, 0 )\n    \n    # -- Section A : socially useful activity and study\n    #    We use the Heinrich 1984 QOL item Instrumental Role\n    #    which ranges from 0-1 (severe) through 6-5 excellent\n    #    So, we operationalise this as 'marked' (==1) if score of <= 3 \n    thresh.A <- ifelse( V$A.social <= 3, 1, 0 )\n    \n    # -- Section B : Personal and social\n    #    Similar rubric to Section A, but we use Heinrich's QOL Interpersonal relations score\n    #    Again, we set 'marked' flag (==1) if score <= 3\n    thresh.B <- ifelse( V$B.personal <= 3, 1, 0)\n    \n    # -- Section C: Self-care.\n    #    More complicated, because there are a number of QOL items to consider\n    #    -- 'marked' in this context (morosini 2000) is \"able to [do something] without\n    #    professional or social help' \n    #\n    #    -- 'severe' is \"unable to perform any role in that area [self-care] if not professionally helped\".\n    \n    #    We can't disambiguate between marked and severe, but the data in C.accom, C.selfcare and C.indep\n    #    tell us if the patient would be *at least* marked which is the threshold requirement\n    \n    #    So, to rate as 'marked' level, the patient (morosini 2000) must have at least problems in \n    #    self care as well as at least some help to maintain normal level.\n    #    We suggest, then, that V$C.selfcare <= 3 (range 0 worst, 4 best) implies deficit in at least one area\n    #    of chores, self care, laundry or clean room.  Further, if V$C.indep <= 3 this implies help in at least\n    #    one area. Finally, if the patient lives in <= 3 accomodation (moderately supported) this implies\n    #    help from professionals or at worst, homelessness.\n    #\n    # -- Final Rubric : ( selfcare <= 3 AND indep <= 3 ) OR ( accom <= 3 ) ==> marked impairement\n    thresh.C <- ifelse( ( V$C.selfcare <= 3 & V$C.indep <= 3 ) | V$C.accom <=3, 1, 0 )\n    \n    ## Rule : from Morosini 2000 (our version underestimates impairment overall because of )\n    ## -- Overall : Moderate or worse if ...\n    ##    thresh.D == 1 (at least by above definition)\n    ##    OR thresh.A OR thresh.B OR thresh.C == 1 (marked)\n    A.to.C <- thresh.A + thresh.B + thresh.C   ## if any is 1, then sum > 1\n    moderate.sofas <- ifelse( A.to.C >= 1 | thresh.D == 1, 1, 0  )\n    \n    return( moderate.sofas  )\n  }\n  \n  # -- assembled the SOFAS for every participant and every visit / assessment\n  TRS.sofas.traj <- sofasAboveThresh( SOFAS[, c(\"A.social\", \"B.personal\", \"C.accom\", \"C.selfcare\", \"C.indep\", \"D.aggress\")] ) \n  TRS.sofas.traj <- cbind( SOFAS[ , c(\"src_subject_id\", \"phase_ct\", \"visday\", \"truncvis\",\n                                 \"A.social\", \"B.personal\", \"C.accom\", \"C.selfcare\", \"C.indep\", \"D.aggress\")], TRS.sofas.traj )\n\n# -- Adequate treatment -------------------------------------------------------------------------------------------\n\n# -- Lookup table: codes for the medications available in each phase\n  phase1 <-  c(\"1\" = \"Olanzapine\", \"2\" = \"Quetiapine\", \"3\" = \"Risperidone\", \"4\" = \"Ziprasidone\", \"5\" = \"Perphenazine\")\n  phase2  <- c(\"1\" = \"Olanzapine\", \"2\" = \"Quetiapine\", \"3\" = \"Risperidone\", \"4\" = \"Ziprasidone\", \"5\" = \"Perphenazine\",\n               \"6\" = \"Clozapine\")\n  \n  phase3  <- c(\"1\" = \"Olanzapine\", \"2\" = \"Quetiapine\", \"3\" = \"Risperidone\", \"4\" = \"Ziprasidone\", \"5\" = \"Perphenazine\",\n               \"6\" = \"Clozapine\", \"7\" = \"Fluephenazine-D\", \"8\" = \"Aripiprazole\")\n\n\n# -- we'll use a simple structure to record a participants medication / treatment history\n  setClass(\"rxRecord\",\n           slots = list(ID = \"numeric\", \n                        all.phases.rx.num = \"data.frame\",\n                        all.phases.rx.lbl = \"data.frame\",\n                        phase1 = \"data.frame\",\n                        phase1b = \"data.frame\",\n                        phase2 = \"data.frame\",\n                        phase31 = \"data.frame\",\n                        phase32 = \"data.frame\",\n                        rxElig = \"data.frame\",\n                        rxN = \"numeric\",\n                        eligibleRxN = \"numeric\"))\n  \n\n  # -- this function is the key unit of processing for each participant  \n  computePhaseDrugs <- function( subRow, subDose, thisID ) {\n  \n    # -- extract treatment from each phase\n    rx.phase1  <- phase1[ subRow$treat11a   ]\n    rx.phase1b <- phase1[ subRow$treat_1b  ]\n    rx.phase2  <- phase2[ subRow$treat2    ]\n    rx.phase31 <- phase3[ subRow$treat_31  ]\n    rx.phase32 <- phase3[ subRow$treat_32  ]\n    \n    phases.rx <- c(\"Phase1\" = subRow$treat11a, \"Phase1b\" = subRow$treat_1b,\n                   \"Phase2\" = subRow$treat2,  \"Phase31\" = subRow$treat_31, \"Phase32\" = subRow$treat_32 )\n    \n    phases.rx.lbl <- data.frame(Phase1 = rx.phase1, Phase1b = rx.phase1b,\n                       Phase2 = rx.phase2, Phase31 = rx.phase31, Phase32 = rx.phase32, stringsAsFactors = FALSE )\n    \n    rx.hx <- new(\"rxRecord\", ID = thisID, all.phases.rx.num = data.frame( phases.rx ),\n                 all.phases.rx.lbl = phases.rx.lbl)\n    \n    # -- for each phase : \n    if( !is.na( phases.rx[\"Phase1\"] ) ) {\n      this.rx <- subDose[ subDose$phase_ct == \"Phase 1/1A\", \n                                         c(\"ID\", \"phase_ct\",\"visitid\", \"visit\", \"visday\", \"dose1\", \"medad14\") ]\n      if( !nrow( this.rx ) < 1 ) { # data not missing\n        names(this.rx) <- c(\"ID\", \"PhaseLbl\", \"VisitID\", \"VisitLbl\", \"VisitDay\",\"Dose\",\"Adherence\")\n        this.rx$RxNumeric <- as.numeric( phases.rx[\"Phase1\"] )\n        this.rx$RxLbl     <- rx.phase1\n        \n        # replace NA with 0, because if no dose record, assume 0 and we'll exclude later as ineligible\n        this.rx$Dose[ which( is.na( this.rx$Dose ) ) ] <- 0 \n        rx.hx@phase1 <- this.rx\n      }\n    }\n    \n    if( !is.na( phases.rx[\"Phase1b\"] ) ) {\n      this.rx <- subDose[ subDose$phase_ct == \"Phase 1B\", \n                          c(\"ID\", \"phase_ct\",\"visitid\", \"visit\", \"visday\", \"capsules\", \"medad14\") ]\n      \n      if( !nrow( this.rx ) < 1 ) { # data not missing\n        # note : there is NO recorded dose for phase1B (don't know why) so we have to infer from schedule\n        # in study protocol pp39\n        # Then, capsules * drug dose = total dose\n        mg.dose <- switch( rx.phase1b,\n                              \"Olanzapine\" = 7.5,\n                              \"Quetiapine\" = 200,\n                              \"Risperidone\" = 1.5,\n                              \"Ziprasidone\" = 40,\n                              \"Perpenazine\" = 8,\n                               stop(\"Error! Cannot compute Phase1b drug dose\") ) \n    \n        this.rx$capsules <- this.rx$capsules * mg.dose    \n        names(this.rx) <- c(\"ID\", \"PhaseLbl\", \"VisitID\", \"VisitLbl\", \"VisitDay\",\"Dose\",\"Adherence\")\n        this.rx$RxNumeric <- as.numeric( phases.rx[\"Phase1b\"] )\n        this.rx$RxLbl     <- rx.phase1b\n        this.rx$Dose[ which( is.na( this.rx$Dose ) ) ] <- 0 \n        rx.hx@phase1b     <- this.rx\n      }\n    }\n    \n    if( !is.na( phases.rx[\"Phase2\"] ) ) {\n      \n      # slight hitch here : if Clozapine in phase 2, then we need medad07 (not dose 2 !!!)\n      this.rx <- subDose[ subDose$phase_ct == \"Phase 2\", \n                          c(\"ID\", \"phase_ct\",\"visitid\", \"visit\", \"visday\", \"dose2\", \"medad14\") ]\n      \n      if( !nrow( this.rx ) < 1 ) { # data not missing\n        names(this.rx) <- c(\"ID\", \"PhaseLbl\", \"VisitID\", \"VisitLbl\", \"VisitDay\",\"Dose\",\"Adherence\")\n        this.rx$RxNumeric <- as.numeric( phases.rx[\"Phase2\"] )\n        this.rx$RxLbl     <- rx.phase2\n        this.rx$Dose[ which( is.na( this.rx$Dose ) ) ] <- 0 \n        rx.hx@phase2      <- this.rx\n      }\n    }\n    \n    if( !is.na( phases.rx[\"Phase31\"] ) ) {\n      # use subDose\n      # drug.1 <- subDose$medad08\n      # drug.2 <- subDose$medad11\n      # dose.1 <- subDose$medad10\n      # dose.2 <- subDose$medad13\n      \n      this.rx <- subDose[ subDose$phase_ct == \"Phase 3\", \n                          c(\"ID\", \"phase_ct\",\"visitid\", \"visit\", \"visday\", \"medad10\", \"medad14\") ]\n      if( !nrow( this.rx ) < 1 ) { # data not missing\n        names(this.rx) <- c(\"ID\", \"PhaseLbl\", \"VisitID\", \"VisitLbl\", \"VisitDay\",\"Dose\",\"Adherence\")\n        this.rx$RxNumeric <- as.numeric( phases.rx[\"Phase31\"] )\n        this.rx$RxLbl <- rx.phase31\n        this.rx$Dose[ which( is.na( this.rx$Dose ) ) ] <- 0 \n        rx.hx@phase31 <- this.rx\n      }\n    }\n    \n    if( !is.na( phases.rx[\"Phase32\"] ) ) {\n      this.rx <- subDose[ subDose$phase_ct == \"Phase 3\", \n                          c(\"ID\", \"phase_ct\",\"visitid\", \"visit\", \"visday\", \"medad13\", \"medad14\") ]\n      if( !nrow( this.rx ) < 1 ) { # data not missing\n        names(this.rx) <- c(\"ID\", \"PhaseLbl\", \"VisitID\", \"VisitLbl\", \"VisitDay\",\"Dose\",\"Adherence\")\n        this.rx$RxNumeric <- as.numeric( phases.rx[\"Phase32\"] )\n        this.rx$RxLbl <- rx.phase32\n        this.rx$Dose[ which( is.na( this.rx$Dose ) ) ] <- 0 \n        rx.hx@phase32 <- this.rx\n      }\n    }\n    \n    #set eligibility number to 0 for all records until processed later by summary_phase\n    rx.hx@rxN <- 0\n    \n    return( rx.hx )\n  }\n\n\n# -- For all participants, compute drug allocations throughout the trial\n#    This results in a data.frame with one row per participant, and columsn being the names\n#    of medications allocated in each phase (1 through 3)\n  \n  allIDs <- unique( subRx$ID )\n  allDrugs <- vector(\"list\", length(allIDs))\n\n  pb <- txtProgressBar(min = 1, max = length(allIDs), initial = 0)\n  for( i in 1:length( allIDs ) ) {\n    setTxtProgressBar(pb, i)\n    thisID <- allIDs[i]\n    subRow   <- subRx[ subRx$ID == thisID, ]\n    subDose  <- drug.doses[ drug.doses$ID == thisID, ]\n    \n    test <- computePhaseDrugs( subRow, subDose, thisID )\n    allDrugs[[i]] <- test\n\n  }\n  close(pb)\n  \n\n# -- The data sheets (SPCs) used to compute the mid-range dosing thresholds\n  # ziprasidone : http://labeling.pfizer.com/ShowLabeling.aspx?id=584\n  # Olanzapine : http://pi.lilly.com/us/zyprexa-pi.pdf\n  # Risperidone : http://www.janssen.com/us/sites/www_janssen_com_usa/files/products-documents/risperdal-prescribing-information.pdf\n  # Perphenazine : https://www.medicines.org.uk/emc/medicine/22596\n  # Quetiapine : https://www.medicines.org.uk/emc/medicine/2295 and http://www.azpicentral.com/seroquel/seroquel.pdf\n  # CLozapine : https://www.medicines.org.uk/emc/medicine/32564\n  # Fluphenazine depot : http://www.medicines.org.uk/emc/medicine/6956/SPC/Modecate+Injection+25mg+ml\n  # Aripiprazole : https://www.accessdata.fda.gov/drugsatfda_docs/label/2014/021436s038,021713s030,021729s022,021866s023lbl.pdf\n\n# -- Lookup table of midrange doses\nSPC.min <- list(\"Ziprasidone\" = 120,          ## SPC : 20--100mg BD ==> 40--200mg TDD ==> midpoint is 40 + (200-40)/2 = 120\n                \"Olanzapine\" = 12.5,          ## SPC : 10-15mg TDD ==> midpoint is 10 + (15-10)/2 = 12.5\n                \"Risperidone\" = 10,           ## SPC : 4--16mg TDD ==> midpoint is 4 + (16-4)/2 = \n                \"Perphenazine\" = 18,          ## SPC : 4mg TDS ==> 12mg TDD to max of 24mg TDD => midpoint is 12 + (24-12)/2 = 18\n                \"Quetiapine\" = 450,           ## SPC : 150mg -- 750mg daily ==> midpoint is 150 + (750 - 150)/2\n                \"Clozapine\" = 325,            ## SPC : 200-450mg daily ==> midpoint is 200 + (450-200)/2\n                \"Fluephenazine-D\" = 56.25,    ## SPC : 12.5mg -- 100mg two weekly ==> midpoint is 12.5 + (100-12.5)/2\n                \"Aripiprazole\" = 20)          ## SPC : 10-30mg daily ==> midpoint is 10 + (30-10)/2\n\n\n# -- Function to summarise a phase\n  summary_phase <- function( df, last.phase.day ) {\n    # -- pass any phase record (phase slots class rxRecord) and this will summarise the\n    #    adherence, minimum and mean and SD dose and assess if this phase is eligible for a successful trial\n    \n    # catch missing data\n    if( nrow( df ) == 0 ) { \n      return( NULL )\n    }\n    \n    # compute difference of days for duration calc\n    df$rxDur <- diff( c( last.phase.day, df$VisitDay ) )\n    \n    accept.dose <- as.numeric( SPC.min[ df$RxLbl[1] ] )\n    \n    # select rows where : adherence == 1 and dose is adequate.\n    df$adqDose.rx   <- ifelse( df$Dose >= accept.dose, 1, 0 )\n    df$AdherDose.rx <- ifelse( df$Adherence == 1 & df$adqDose.rx == 1, 1, 0 )\n    \n    # meets criteria on time ?\n    duration      <- sum( df$rxDur[ which( df$AdherDose.rx == 1) ] )\n    if( duration >= 42 ) {  \n        # at least some of the drug trial meets criteria for duration\n        # so record dose information for those rows \n        mean.dose     <- mean( df$Dose[ which( df$AdherDose.rx == 1) ] )\n        SD.dose       <- sd( df$Dose[ which( df$AdherDose.rx == 1) ] )\n        quantile.dose <- quantile( df$Dose[ which( df$AdherDose.rx == 1) ] )\n        adeqTrial     <- 1   # we know this is true, because AdherDose == 1 iff Aherence and Dose are above threshold\n      \n    } else {\n        # if not eligible on adherence and dose, then just summarise for record keeping\n        mean.dose     <- mean( df$Dose )\n        SD.dose       <- sd( df$Dose )\n        quantile.dose <- quantile( df$Dose )\n        adeqTrial       <- 0\n        duration        <- sum( df$rxDur )\n    }\n    \n    return( data.frame( \n                  drugLbl = df$RxLbl[1], meanDose = mean.dose, sdDose = SD.dose,\n                  minDose = quantile.dose[1], \n                  medianDose = quantile.dose[3],\n                  maxDose = quantile.dose[5],\n                  IQR = quantile.dose[4] - quantile.dose[2],\n                  rxDuration = duration, \n                  adeqTrial = adeqTrial,\n                  phase = factor( df$PhaseLbl[1], levels = trialPhases ),\n                  last.visit.day = df$VisitDay[ nrow(df) ]\n                        )\n    )\n     \n  }\n\n# -- For each participant in allDrugs, summarise the treatment given ----------------------------------------------\n  for( i in 1:length( allDrugs ) ) {\n    \n         # retrieve the record:\n         thisRx <- allDrugs[[i]]\n  \n         # inspect phase1, phase1b, phase2, phase31 and phase32 for adherence as well as\n         # adequate dosing\n         \n         store.rx <- data.frame()\n  \n         # with phase1\n         ph1 <- summary_phase( thisRx@phase1, 1 )\n         \n         if( !is.null( ph1 ) ) {\n            last.phase.day <- thisRx@phase1$VisitDay[ nrow(thisRx@phase1) ]\n            store.rx <- rbind( store.rx, ph1 )\n         }\n         \n         # phase1b\n         if( nrow( thisRx@phase1b ) > 0 ) {\n           ph1b <- summary_phase( thisRx@phase1b, last.phase.day )\n           if( !is.null( ph1b ) ) {\n            store.rx <- rbind( store.rx, ph1b )\n            last.phase.day <- thisRx@phase1b$VisitDay[ nrow(thisRx@phase1b) ]\n           }\n         } else {\n           ph1b <- NULL\n         } \n         \n         # phase 2\n         if( nrow( thisRx@phase2 ) > 0 ) {\n           ph2 <- summary_phase( thisRx@phase2, last.phase.day )\n           if( !is.null( ph2 ) ) {\n              store.rx <- rbind( store.rx, ph2 )\n              last.phase.day <- thisRx@phase2$VisitDay[ nrow(thisRx@phase2) ]\n           }\n         } else {\n           ph2 <- NULL\n         }\n         \n         # phase 31\n         if( nrow( thisRx@phase31 ) > 0 ) {\n           ph31 <- summary_phase( thisRx@phase31, last.phase.day )\n           if( !is.null( ph31  ) ) {\n             store.rx <- rbind( store.rx, ph31 )\n           }\n         }\n  \n         if( nrow( thisRx@phase32 ) > 0 ) {\n           ph32 <- summary_phase( thisRx@phase32, last.phase.day )\n           if( !is.null( ph32 ) ) {\n             store.rx <- rbind( store.rx, ph32 )\n           }\n         }\n         \n         thisRx@rxElig <- store.rx\n         allDrugs[[i]] <- thisRx\n         \n    \n  }\n\n# -- loop over records in allDrugs, compute total trials and eligible adequate trials including phase at which this occurs\n  for( i in 1:length( allDrugs ) ) {\n    thisSub <- allDrugs[[i]]@rxElig\n    \n    if( nrow( thisSub ) > 0 ) {\n      thisSub <- thisSub[ order( thisSub$phase ), ]\n      \n      thisSub$numericPhase <- numeric.trialPhases[ thisSub$phase ]\n      # recall : numeric phase\n      # Pre-Rand Phase 1/1A   Phase 1B    Phase 2    Phase 3    Phase 4 \n      # 1          2          2           3          4          4 \n      # now everything in trial-order, we can compute cumulative *adequate* trials -- BUT NOT necessarily unique\n    \n      # 0 => drug same as previous phase, 1 ==> different\n      thisSub$diffDrugs <- c( 0, diff( as.numeric( thisSub$drugLbl ) ) )\n      \n      thisSub$cumAdeqRx <- rep(0, nrow(thisSub))\n      thisSub$cumRx     <- rep(0, nrow(thisSub))\n      \n      if( thisSub$adeqTrial[1] == 1 ) { thisSub$cumAdeqRx[1] <- 1 }\n      \n      thisSub$cumRx[1] <- 1\n      \n      if( nrow( thisSub ) > 1 ) {\n        for( j in 2:nrow( thisSub ) ) {\n          \n          if( thisSub$diffDrugs[j] == 1) { \n            thisSub$cumRx[j] <- thisSub$cumRx[j-1] + 1 \n          } else { \n            thisSub$cumRx[j] <- thisSub$cumRx[j-1]   \n          }\n          \n          if( thisSub$adeqTrial[j] == 1 & thisSub$diffDrugs[j] == 1 ) {\n            thisSub$cumAdeqRx[j] <- thisSub$cumAdeqRx[j-1] + 1\n          } else { \n            thisSub$cumAdeqRx[j] <- thisSub$cumAdeqRx[j-1] \n          }\n          \n        } # end for j\n      } # end  if( nrow( thisSub ) > 1 )\n    } # end if( nrow( thisSub ) > 0 )\n    \n    allDrugs[[i]]@rxElig <- thisSub\n    if( nrow( thisSub ) > 0 ) {\n      allDrugs[[i]]@rxN          <- length( unique( thisSub$drugLbl ) )    # total Rx trials, NOT necessarily adequate\n      allDrugs[[i]]@eligibleRxN  <- max( thisSub$cumAdeqRx )\n    } else {\n      allDrugs[[i]]@rxN    <- 0\n      allDrugs[[i]]@eligibleRxN  <- 0\n    }\n  }\n\n# -- Finally, build the final tabulated list of all participant's medication \"trajectories\" throughout trial -----\n  TRS.rx.traj <- data.frame()\n  for( i in 1:length(allDrugs) ) {\n    # this subject ID and summary of rxs\n    thisID <- allDrugs[[i]]@ID\n    thisRx <- allDrugs[[i]]@rxElig\n    if( nrow( thisRx ) > 0 ) {\n      # append ID\n      thisRx$ID <- rep(thisID, nrow( thisRx ))\n      TRS.rx.traj <- rbind( TRS.rx.traj, thisRx )\n    }\n  } \n\n# -- Build a final tabulated list of all participant's Symptoms throughout trial ---------------------------------\nuni.IDs <- unique( TRS.sx$src_subject_id )\nTRS.sx.traj <- data.frame( ID = numeric(),\n                           phase = factor(),# character(),\n                           truncvis = numeric(),\n                           visday = numeric(),\n                           TRS.pos = numeric(),  #absolute symptom criteria POS, NEG and GEN\n                           TRS.neg = numeric(),\n                           TRS.gen = numeric(),\n                           adjPos  = numeric(),\n                           adjNeg  = numeric(),\n                           adjGen  = numeric(),\n                           adjTot  = numeric()\n)\n\nfor( i in 1:length( uni.IDs ) ) {\n  thisID <- uni.IDs[i]\n  # retrieve all rows relevant to thisID from TRS.sx\n  thisSubIdx    <- which(TRS.sx$src_subject_id == thisID)\n  thisSub       <- TRS.sx[ thisSubIdx, ]\n  thisSubIdx.F5 <- which(PANSS.F5$ID == thisID)\n  thisSub.F5    <- PANSS.F5[ thisSubIdx.F5, ] \n  \n  if( nrow( thisSub ) < 2 ) {\n    # no progression data to estimate trajectory i.e. subject left study very early with only one record/assessment\n    \n    thisEntry <- data.frame( ID = thisID,\n                             phase = thisSub$phase_ct,\n                             truncvis = thisSub$truncvis,\n                             visday = thisSub$visday,\n                             TRS.pos = NA,  #absolute symptom criteria POS, NEG and GEN\n                             TRS.neg = NA,\n                             TRS.gen = NA,\n                             adjPos  = NA,\n                             adjNeg  = NA,\n                             adjGen  = NA,\n                             adjTot  = NA\n                             )\n  } else {\n    # organise into ascending visit order, so changes can be computed\n    thisSub    <- thisSub[ order( thisSub$truncvis), ]\n    thisSub.F5 <- thisSub.F5[ order( thisSub.F5$truncvis), ]\n    \n    # compute trajectory\n    # percentage decrease in total PANSS (Leucht 2009)\n    traj.totalPANSS <- (thisSub$total.POS + thisSub$total.NEG + thisSub$total.GEN) - 30\n    traj.totalPANSS.F5 <- (thisSub.F5$F5.pos + thisSub.F5$F5.neg + thisSub.F5$F5.disorg + thisSub.F5$F5.excite + thisSub.F5$F5.depanx) - 27\n\n    # absolute criteria for pos, neg and gen domains as per aboveThresh function (see above for explaination)\n    absTRS.pos <- thisSub$TRS.pos\n    absTRS.neg <- thisSub$TRS.neg\n    absTRS.gen <- thisSub$TRS.gen\n\n    thisEntry <- data.frame( ID = thisID,\n                             phase = thisSub$phase_ct,\n                             truncvis = thisSub$truncvis,\n                             visday = thisSub$visday,\n                             TRS.pos = absTRS.pos,\n                             TRS.neg = absTRS.neg,\n                             TRS.gen = absTRS.gen,\n                             adjPos  = thisSub$adj.total.POS,\n                             adjNeg  = thisSub$adj.total.NEG,\n                             adjGen  = thisSub$adj.total.GEN,\n                             adjTot  = traj.totalPANSS                            \n    )\n    \n  }\n  TRS.sx.traj <- rbind( TRS.sx.traj, thisEntry )\n}\n\n# -- Workaround to make dealing with different factor levels easier --------------------------\nx <- TRS.sofas.traj$phase_ct\ny <- TRS.sx.traj$phase\nz <- TRS.rx.traj$phase\nallvalues <- unique(union(z,union(x,y)))\nTRS.sofas.traj$phase_ct <- factor(x, levels = allvalues)\nTRS.sx.traj$phase <- factor(y, levels = allvalues)\nTRS.rx.traj$phase <- factor(z, levels = allvalues)\n\n# -- need to rename SOFAS fields\nTRS.sofas.traj$ID <- TRS.sofas.traj$src_subject_id\nTRS.sofas.traj$phase <- TRS.sofas.traj$phase_ct\n\n# -- clean environment for next script, keeping only necessary dataframes / variables\nkeepVars <- c(\"TRS.sx.traj\",\"TRS.rx.traj\",\"TRS.sofas.traj\",\"allIDs\",\"keyvars\",\"demog.tab\",\"PANSS.tab\",\"pmhx.tab\",\"SCID.tab\",\"root.path\",\"data.path\")\nrm( list = ls()[ which( !(ls() %in% keepVars) ) ] )\n\n",
    "created" : 1524231346702.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2590948240",
    "id" : "1701ABD4",
    "lastKnownWriteTime" : 1524156768,
    "last_content_update" : 1524156768,
    "path" : "~/Dropbox/CATIE_Multivar/CATIE_TRS/FinalTRSPaper/Code/preprocess_trajectories.R",
    "project_path" : "preprocess_trajectories.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}