{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Sample Walk-Through for Determining TRS Status\"\nauthor: Dan W Joyce\ndate: \"19th April 2018\"\noutput:\n  html_document:\n    toc: true\n    number_sections: true\n    toc_float: true\n\n---\n\n# Introduction\nThe script `tabulate_cases.R` -- for tabulating each participant and deciding on treatment resistance and responsive cases -- is long and confusing.  This notebook walks through an example case for a TRS participant, hopefully exposing the logic used by executing each chunk and illustrating the results.\n\n```{r message = FALSE}\nrequire(knitr)\nsource(\"preprocess_trajectories.R\")\n```\n\n# Walk-through for a TRS Case\nAfter executing `preprocess_trajectories.R`, we have three tables :\n  \n  * `TRS.rx.traj` containing the treatment history for all participants in CATIE\n  * `TRS.sofas.traj` containing the history of SOFAS/PSP proxy measures for all participants in CATIE\n  * `TRS.sx.traj` containing the symptoms (PANSS) history for all participants in CATIE\n  * `allIDs` is a vector containing the CATIE ID numbers for all participants in CATIE such that N = `r length( allIDs )`\n\nAs an example to walk-through, participant ID = 1438 is detected as a TRS case and this corresponds to index 12 in `allIDs`\n\nWe set `i = 12` to select participant 1438 :\n```{r}\ni <- 12\n```\n\nWe reproduce the helper functions here so this walk-through will execute:\n```{r}\n# -- Some helper functions to make the following big loop easier to read ------------------\n  CreateNewRow <- function() {\n    return( \n      data.frame( \n        ID = thisID,\n        time.inTrial = keyvars$es_day[ which( keyvars$src_subject_id == thisID ) ],    # use end of study day as default\n        \n        onset.Sx  = NA,\n        onset.SOF = NA,\n        onset.Rx  = NA,\n        \n        time.onset.TRS = NA,\n        \n        time.TRS  = NA,\n        \n        numAdeq = NA,\n        durAdeq = NA,\n        totalRx = NA,\n        \n        status.rx = NA,\n        status.sx = NA,\n        status.sof = NA,\n        status.TRS = NA,\n        \n        TRS.pos = 0,       # resistance in pos domain\n        TRS.neg = 0,       # resistance in neg domain\n        \n        missing.Sx = 0,\n        missing.Rx = 0,\n        missing.SOF = 0\n      )\n    )\n  }\n\n# -- Function to check if a given participant is missing Rx, Sx and SOF data (to the extent we cannot)\n#    robustly process the participant further\nCheckZeroRecords <- function( thisRow, thisRx, thisSx, thisSOF ) {\n  # -- first, catch case where patient drops out with no real data\n  # -- NB : assumes missing.Rx, missing.Sx and missing.SOF are in global environment.\n  \n  # -- we do this by looking at Rx trajectory : \n  if ( nrow( thisRx ) < 1 )  { ## no treatments recorded at all\n    thisRow$status.rx <- NA\n    thisRow$totalRx   <- NA\n    noFurtherFlag <- 1    ## tell rest of loop to not bother\n    missing.Rx <- c( missing.Rx, thisID )\n    thisRow$missing.Rx <- 1\n  }\n  \n  # -- second, catch situation where Sx is missing - so we cannot assess response to treatment\n  if ( nrow( thisSx ) < 1 ) {\n    thisRow$status.sx <- NA\n    noFurtherFlag <- 1    ## tell rest of loop to not bother\n    missing.Sx <- c( missing.Sx, thisID )\n    thisRow$missing.Sx <- 1\n  }\n  \n  # -- third, catch situation where SOF is missing - so we cannot assess social/occ functioning\n  if ( nrow( thisSOF ) < 2 ) {\n    thisRow$status.sof <- NA\n    missing.SOF <- c( missing.SOF, thisID )\n    thisRow$missing.SOF <- 1\n  }\n  \n  return( list( thisRow, noFurtherFlag ) )\n  \n}\n\n```\n\n# Main Loop\n\n## Retrieve Participant's Data\nThe first part of the large loop determining TRS cases:\n```{r eval = FALSE}\n# -- Now track each participant ------------------------------------------------------------------------------------------\n  for ( i in 1:length( allIDs ) ) {\n```\n\nIs this:\n```{r}\n     \n    # -- for this participant ...\n    thisID <- allIDs[i]\n    \n    # -- fetch Sx, SOF and Rx (stored in TRS.sx.traj, TRS.sofas.traj, and TRS.rx.traj) \n    # -- all output from \"TRS_CATIE_v3.R\"\n    thisSx  <- TRS.sx.traj[ which( TRS.sx.traj$ID == thisID ), ]\n    thisSOF <- TRS.sofas.traj[ which( TRS.sofas.traj$ID == thisID ), ]\n    thisRx  <- TRS.rx.traj[ which( TRS.rx.traj$ID == thisID ), ]\n  \n    noFurtherFlag <- 0\n  \n    # -- build a blank data.frame to store this participant\n    thisRow <- CreateNewRow()\n```\n\nResulting in three dataframes for this participant.\n\nThe PANSS / symptoms history:\n```{r}\nkable( thisSx )\n```\n\nThe SOFAS history:\n```{r}\nkable( thisSOF)\n```\n\nAnd the treatments history\n```{r}\nkable( thisRx )\n```\n\nFinally, an unpopulated \"blank row\" for the final dataframe is created which looks like:\n```{r}\nkable( thisRow )\n```\n\n\n## Check for \"Zero Data\" Conditions\n\nThe next chunk checks for participants where there is no usable data -- for example, if there is missing data for SOF, Sx, or Rx -- and `thisRow` is filled accordingly.  This is performed by the helper `CheckZeroRecords` which also returns a flag `= 1` telling the remainder of the loop not to do any further processing.  \n\n```{r}\n    # -- check for \"zero\" records for this participant\n    check.zero    <- CheckZeroRecords( thisRow, thisRx, thisSx, thisSOF )\n    noFurtherFlag <- check.zero[[2]]\n    thisRow       <- check.zero[[1]]\n```\n\nWhich for this examplar case results in `noFurtherFlag` = `r noFurtherFlag` because there is data to use in assessing TRS status.\n\n## When Participant Does Have Data\n\nWe check `noFurtherFlag == 0` indicating data is present and there's further work to be done on this participant ...\n\n```{r eval = FALSE}\n    # -- if we have treatment (Rx) data, then process Sx trajectory\n    if ( noFurtherFlag == 0 ) {\n```\n\nAfter checking for the (few) cases where visit days don't make sense, we then order `thisSOF`, `thisSX` and `thisRx` on `visday` column to make sure they are in ascending time order:\n\n```{r}\n\n      # -- there is at least one participant who's last.visit.day in thisRx is later than the thisSx.visday\n      #    and thisSOF.visday : capture this, and set last.visit.day equal to the last day of thisSx.visday\n      if ( thisRx$last.visit.day[ nrow(thisRx) ] > thisSx$visday[nrow(thisSx)] ) {\n        thisRx$last.visit.day[ nrow(thisRx) ] <- thisSx$visday[nrow(thisSx)]\n      }\n      \n      # -- order SOF by visday\n      thisSOF <- thisSOF[ order( thisSOF$visday ), ]\n      # -- remove duplicated SOF rows\n      thisSOF <- thisSOF[ !duplicated( thisSOF ), ]\n      \n      # -- Same for symptoms \n      thisSx  <- thisSx[ order( thisSx$visday ), ]\n      thisSx  <- thisSx[ !duplicated( thisSx ), ]\n      # -- and treatments (for which there are never any duplicates)\n      thisRx  <- thisRx[ order( thisRx$last.visit.day ), ]\n```\n\nNext, we (left) join `thisSx`, `thisSOF` and `thisRx` on `visday`, subsetting only on the columns we need:\n\n```{r}\n      # -- join a subset of columns in thisSx and thisSOF with thisRx to compile TRS status \n      temp <- left_join( thisSx, \n                         thisSOF[ , names(thisSOF) %in% c(\"visday\",\"TRS.sofas.traj\") ],\n                         by = \"visday\" )  \n      \n      temp <- left_join( temp, thisRx[ names(thisRx) %in% c(\"rxDuration\",\"adeqTrial\",\"cumAdeqRx\",\"cumRx\",\"last.visit.day\") ],\n                         by = c(\"visday\" = \"last.visit.day\") )\n```\n\nThen, we set flags in `temp` for when symptoms (Sx) first \"trigger\" above the **absolute** threshold for positive and negative domains and another flag for when **both** social/occupational function (SOF) and Sx trigger -- these are the absolute criteria in the TRRIP concensus.\n\n```{r}\n     # --------------- time at which participant *first* triggers thresholds for SOF and Sx and Rx\n      temp$onsetSxFlag <- ifelse(   ( temp$TRS.pos == 1 |\n                                      temp$TRS.neg == 1 ), 1, 0\n      )\n      \n      # -- flag if the participant reached *BOTH* Sx and SOF criteria\n      temp$SOF.and.Sx.TRS <- ifelse( temp$onsetSxFlag== 1 & temp$TRS.sofas.traj == 1, 1, 0 )\n```\n\nResulting in :\n\n```{r}\nkable( temp )\n```\n\nWe now select the rows of `temp` which have cumulative numbers of adequate treatment:\n\n```{r}\n      # -- filter on cumAdeqRx\n      temp2 <- temp[ which( !is.na( temp$cumAdeqRx ) ), ]\n```\n\nResulting in an auxillary dataframe `temp2` which is helpful later:\n```{r}\nkable( temp2 )\n```\n\nWe next store the number of adequate treatment trials, the total duration of adequate treatments and the total number of treatments (adequate or otherwise) respectively:\n\n```{r}\n      # -- Store number of adequate trials, duration of adequate trials and total treatments\n      numAdeq <- max( thisRx$cumAdeqRx )\n      durAdeq <- sum( thisRx$rxDuration[ which( thisRx$adeqTrial == 1 ) ] )\n      totalRx <- max( thisRx$cumRx )\n```\n\nUsing `temp2` we establish if absolute SOF and Sx are triggered together -- this was flagged earlier in `SOF.and.Sx.TRS`:\n\n```{r}\n\n      # flag if ever meets SOF and Sx criteria together\n      idxEver <- which( temp2$SOF.and.Sx.TRS == 1)\n      # -- idxEver : contains rows idxs for when Sx + SOF > threshold\n```\n\nWe've extracted a vector of row indices, and then test if the length of this vector is non-zero to decide if there's data to work with. \n\nThe next chunk catches cases where the participant never had Sx and SOF absolute thresholds triggering together (and so, can never be TRS), and populates `thisRow` with relevant values for cases where the participant never reaches the absolute thresholds on Sx or SOF:\n\n```{r eval = FALSE}\n\n      # -- if NEVER has Sx and SOF criteria together then set variables to record non-TRS ...\n      if( length( idxEver ) == 0 ) {\n                \n                idxFirstSx  <- which( temp$onsetSxFlag == 1 )\n                idxFirstSOF <- which( temp$TRS.sofas.traj == 1 )\n                idxFirstRx  <- which( thisRx$adeqTrial == 1 )\n                if( length( idxFirstSx ) == 0 ) {\n                  onset.Sx <- NA\n                } else {\n                  onset.Sx  <- temp$visday[ min( idxFirstSx ) ]\n                }\n                \n                if( length( idxFirstSOF ) == 0 ) {\n                  onset.SOF <- NA\n                } else {\n                  onset.SOF <- temp$visday[ min( idxFirstSOF ) ]\n                }\n        \n                # -- as never reaches criteria for Rx >= 2        \n                onset.Rx <- NA\n                \n                time.onset.TRS <- NA\n                time.TRS       <- NA\n                \n                status.rx  <- NA\n                status.sx  <- NA\n                status.sof <- NA\n                status.TRS <- 1    # censored - never met TRS criteria\n                \n                TRS.pos = 0        # obviously, cannot meet resistance in pos domain\n                TRS.neg = 0        # or in neg domain\n      }\n```\n\nFor participant `r thisID`, `length( idxEver )` is `r length( idxEver)` and we skip the above code and move to:\n\n```{r eval = FALSE}\n      # -- if this participant DOES meet Sx and SOF criteria together ... establish TRS status\n      if ( length( idxEver ) > 0 ) {\n        # -- now, ascertain the BASELINE for PANSS change, then when adeqRx >= 2 and\n```\n\nWhere the main bulk of the work is done for cases where the participant **did** meet absolute SOF and Sx criteria at some point in the trial.\n\n## Computing TRS-related Variables\n\nFirst we need the time (the `visday`) at which the participant met the absolute Sx and SOF criteria, and also the `visday` at which they meet the >= 2 adequate treatments (Rx):\n```{r}\n        # -- compute time at which Sx and SOF were \"at risk\" -- i.e. above threshold, but NOT YET had adequate treatment\n        onset.Sx  <- temp$visday[ min( which( temp$onsetSxFlag == 1 ) ) ]\n        onset.SOF <- temp$visday[ min( which( temp$TRS.sofas.traj == 1 ) ) ]\n        \n        # -- and then time at which adequate trials passes threshold >= 2\n        onset.rx.idx <- which( temp$cumAdeqRx >= 2 )\n        if ( length( onset.rx.idx ) == 0 ) { \n          # -- in this case, participant NEVER had >= 2 adequate trials\n          onset.Rx  <- NA\n        } else {\n          # -- otherwise, store time and which they completed >= 2 adequate trials\n          onset.Rx  <- temp$visday[ min( onset.rx.idx ) ]        \n        }\n        \n        # -- compute time at which Sx and SOF were at risk together (but not necessarily the Adequate Rx criteria met)\n        time.onset.TRS <- temp$visday[ min( which( temp$SOF.and.Sx.TRS == 1 ) ) ]\n        \n```\n\nSo, for participant `r thisID`, we establish that they:\n\n  * met absolute SOF criteria at `visday` = `r onset.Sx` (`onset.Sx`)\n  * met absolute Sx criteria at `visday` = `r onset.SOF` (`onset.SOF`)\n  * met **both** Sx and SOF simultaneously on `visday` = `r time.onset.TRS` (`time.onset.TRS`)\n  * and the `visday` at which they had completed 2 adequate treatment trials was `r onset.Rx` (`onset.Rx`)\n\nWe now need to track the **change** in symptoms, as per the TRRIP concensus criteria.\n\nWe extract the baseline PANSS at the timepoint they met both the absolute Sx and SOF criteria (`time.onset.TRS`)\n\n```{r}\n        # -- extract the PANSS scores at time.onset.TRS : this will be the baseline for symptom change measurement\n        baselinePANSS <- temp[ which( temp$visday == time.onset.TRS ), c(\"visday\", \"adjPos\", \"adjNeg\", \"adjGen\", \"adjTot\") ]\n        \n        # -- extract the PANSS scores for followup \n        # -- this will be after 0, 1 or 2 adequate trials and will be the follow-up time for symptom change measurement\n```\n\nResulting in:\n```{r}\nkable( baselinePANSS )\n```\n\nNotice, we use the **adjusted** PANSS scores (making the lowest value 0) so that the Leucht (2009) formula applies (as TRRIP recommends this adjustment for the percentage change criteria).\n\nNext we check : did the participant have **at least** 2 adequate trials?  We can do this by inspecting `onset.Rx` which if NA, means they did not.\nParticipant `r thisID` clearly does, as `onset.Rx` = `r onset.Rx`.  \n\n```{r}\n        # -- never had 2 adequate trials, so we cannot record they were TRS\n        if ( is.na( onset.Rx ) ) {\n          # -- but we still require some measurement of symptom change\n          # -- if they did not have 2 adequate trials, but numAdeq > 0 ==> after one adequate trial, we record PANSS for response\n          if ( numAdeq > 0 ) {\n            followupPANSS <- temp[ min( which( temp$cumAdeqRx == 1 ) ), c(\"visday\", \"adjPos\", \"adjNeg\", \"adjGen\", \"adjTot\") ]\n          } else \n            # -- NEVER had even one adequate trial, so use end of trial\n            # -- find last day with PANSS scores\n            {\n              tempPANSS <- temp[\n                                  complete.cases( temp[ , c(\"visday\", \"adjPos\", \"adjNeg\", \"adjGen\", \"adjTot\") ] ),\n                                  c(\"visday\", \"adjPos\", \"adjNeg\", \"adjGen\", \"adjTot\")\n                                ]\n              followupPANSS <- tempPANSS[ nrow( tempPANSS ), ]\n            }\n        } else\n          # -- Had TWO full adequate trials, and therefore\n          # -- use onset.Rx day as the follow up AFTER 2 adequate trials\n          { \n            followupPANSS <- temp[ which( temp$visday == onset.Rx ), c(\"visday\", \"adjPos\", \"adjNeg\", \"adjGen\", \"adjTot\") ]\n          }\n```\n\nWhich gives us the PANSS score for the time at which the participant completes 2 adequate trials `visday` = `r onset.Rx`:\n\n```{r}\nkable( followupPANSS )\n```\n\nWe do some duplication checking to ensure both `followupPANSS` and `baselinePANSS` are single rows:\n\n```{r}\n        # -- just incase, clear up duplicate panss rows\n        followupPANSS <- followupPANSS[ !duplicated( followupPANSS ), ]\n        baselinePANSS <- baselinePANSS[ !duplicated( baselinePANSS ), ]\n```\n\nBefore computing the percentage change in PANSS after 2 adequate trials (by the Leucht 2009 formula):\n```{r}\n        # -- percentage change in symptoms : Leucht et al, 2009\n        deltaPANSS <- 100 * ( baselinePANSS[ c(\"adjPos\", \"adjNeg\", \"adjTot\") ] - followupPANSS[ c(\"adjPos\", \"adjNeg\", \"adjTot\") ] ) /\n                                followupPANSS[ c(\"adjPos\", \"adjNeg\", \"adjTot\") ]\n```\n\nResulting in a percentage change vector:\n\n```{r}\nkable( deltaPANSS )\n```\n\nThe next step is to assess if the total PANSS, positive and negative domains, have changed by >= 20%:\n```{r}\n        # -- Now, if deltaPANSS >= 20% ==> improvement threshold, therefore NOT TRS on that PANSS domain\n        TRS.change.PANSS.criteria <- ifelse( deltaPANSS >= 20, 0, 1 )\n```\n\nYielding a vector:\n```{r}\nkable( TRS.change.PANSS.criteria )\n```\n\nWhere a `1` indicates the change in symptoms (after 2 adequate treatment trials) was **not greater than** 20%, so they **do** meet TRS on symptom change criteria, and `0` means the change was greater than 20% (and consequently they **do not** meet TRS criteria of symptom change).\n\nNext, record the time at which SOF, Sx and adequate Rx were reached:\n\n```{r}\n        # -- Record time at which SOF, absolute Sx and cumAdeqRx >= 2\n        idxTimeTRS     <- which( temp2$SOF.and.Sx.TRS == 1 & temp2$cumAdeqRx >= 2 )\n        if ( length( idxTimeTRS ) == 0 ) \n          # -- never became TRS\n          { \n            time.TRS       <- NA\n          } else \n          # -- became TRS\n          {\n            time.TRS       <- temp2$visday[ min( idxTimeTRS  ) ]\n          }\n```\n\nSet status flag indicating this participant met the >= 2 **adequate trials** criteria\n```{r}\n        # -- record IF EVER met Rx >= 2 criteria\n        status.rx  <- ifelse( !is.na( onset.Rx ) & onset.Rx  > 0, 1, 0 )\n```\n\nSet status flag recording whether this participant meets the full TRS criteria on **symptom change** which is:\n\n  * Positive **or** negative domain scores have not responded by >= 20%\n  * And overall PANSS (total) score has not responded by >= 20%\n\n```{r}\n        # -- meets change criteria ? 1 => the < 20% change on total *and* one domain \n        status.sx <- ifelse( \n                                ( TRS.change.PANSS.criteria[3] == 1 ) &   # PANSS total change < 20%\n                                ( TRS.change.PANSS.criteria[1] == 1 | TRS.change.PANSS.criteria[2] == 1 ),   # either Pos or Neg domains are resistant\n                                1, 0 )\n```\n\nFinally, check **all** TRRIP criteria have been met (Sx, SOF and Rx), coding `status.TRS` = 2 for full TRS, and 1 otherwise:\n\n```{r}\n        # -- absolute criteria threshold STILL met at followup time ONLY if time.TRS is *not* NA\n        # -- So, check that time.TRS is not NA (==> simultaneously met absolute Sx and Rx conditions)\n        # -- AND that the change in symptoms was actually < 20% -- status.sx.delta\n        if( !is.na( time.TRS ) & status.sx == 1 ) {\n          # -- the SOF + absolute Sx + Rx criteria were ALL met \n          status.TRS <- 2\n        } else {\n          # -- participant is treatment response / censored\n          status.TRS <- 1\n        }\n          \n        status.sof <- ifelse( !is.na( onset.SOF ) & onset.SOF > 0, 1, 0 )\n        TRS.pos = TRS.change.PANSS.criteria[1]       # resistance in pos domain 1,0\n        TRS.neg = TRS.change.PANSS.criteria[2]       # resistance in neg domain 1,0\n        \n```\n\nSome book-keeping:\n\n```{r}\n      # -- complete thisRow and store\n      thisRow$onset.Sx    <- onset.Sx\n      thisRow$onset.SOF   <- onset.SOF\n      thisRow$onset.Rx    <- onset.Rx\n      \n      thisRow$time.onset.TRS <- time.onset.TRS\n      thisRow$time.TRS       <- time.TRS\n      thisRow$status.TRS     <- status.TRS\n      \n      thisRow$numAdeq     <- numAdeq\n      thisRow$durAdeq     <- durAdeq\n      \n      thisRow$totalRx     <- totalRx\n      thisRow$status.rx   <- status.rx\n      thisRow$status.sx   <- status.sx\n      thisRow$status.sof  <- status.sof\n      thisRow$TRS.pos     <- TRS.pos\n      thisRow$TRS.neg     <- TRS.neg\n```\n \nWith the final population `thisRow` vector being:\n   \n```{r}\nkable( thisRow )\n```\n \n `thisRow` is then appended to `tab.Surv` for later use.",
    "created" : 1524142102155.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "640527671",
    "id" : "CB8693AB",
    "lastKnownWriteTime" : 1524156903,
    "last_content_update" : 1524156903411,
    "path" : "~/Dropbox/CATIE_Multivar/CATIE_TRS/FinalTRSPaper/Code/demo_determining_TRS.Rmd",
    "project_path" : "demo_determining_TRS.Rmd",
    "properties" : {
        "chunk_output_type" : "inline",
        "tempName" : "Untitled1"
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}